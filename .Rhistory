progress = FALSE)
tmp <- Sys.time()
cov <- covr::package_coverage(function_exclusions = c("foldExplorer", "rangeExplorer"))
Sys.time() - tmp
rm(tmp)
# print the coverage
cov
# visualise the code coverage
report(cov)
tmp <- Sys.time()
cov <- covr::package_coverage(function_exclusions = c("foldExplorer", "rangeExplorer"))
Sys.time() - tmp
rm(tmp)
# print the coverage
cov
# visualise the code coverage
report(cov)
awt <- raster::brick(system.file("extdata", "awt.grd", package = "blockCV"))
awt_wgs <- raster::projectRaster(awt, crs = sp::CRS("+init=epsg:4326"))
PA <- read.csv(system.file("extdata", "PA.csv", package = "blockCV"))
pa_data <- sf::st_as_sf(PA, coords = c("x", "y"), crs = raster::crs(awt))
pa_data_wgs <- sf::st_transform(pa_data, crs = raster::crs(awt_wgs))
net <- blockCV:::rasterNet(x = pa_data_wgs, resolution = 70000, mask = TRUE)
pa_data_wgs
sf::st_crs(pa_data_wgs) <- NA
pa_data_wgs
net <- blockCV:::rasterNet(x = pa_data_wgs, resolution = 70000, mask = TRUE)
library(covr)
tmp <- Sys.time()
cov <- covr::package_coverage(function_exclusions = c("foldExplorer", "rangeExplorer"))
Sys.time() - tmp
rm(tmp)
# print the coverage
cov
# visualise the code coverage
report(cov)
tmp <- Sys.time()
cov <- covr::package_coverage(function_exclusions = c("foldExplorer", "rangeExplorer"))
Sys.time() - tmp
rm(tmp)
# print the coverage
cov
# visualise the code coverage
report(cov)
library(covr)
# visualise the code coverage
report(cov)
# print the coverage
cov
library(blockCV)
range3 <- spatialAutoRange(rasterLayer = awt2,
# speciesData = pa_data,
doParallel = FALSE)
awt <- raster::brick(system.file("extdata", "awt.grd", package = "blockCV"))
awt <- awt[[1:5]]
nl <- raster::nlayers(awt)
awt2 <- raster::aggregate(awt, 5)
PA <- read.csv(system.file("extdata", "PA.csv", package = "blockCV"))
pa_data <- sf::st_as_sf(PA, coords = c("x", "y"), crs = raster::crs(awt))
awt_wgs <- raster::projectRaster(awt, crs = sp::CRS("+init=epsg:4326"))
range3 <- spatialAutoRange(rasterLayer = awt2,
# speciesData = pa_data,
doParallel = FALSE)
range3 <- spatialAutoRange(rasterLayer = awt2,
speciesData = pa_data,
doParallel = FALSE)
range3 <- spatialAutoRange(rasterLayer = awt2,
speciesData = pa_data,
doParallel = FALSE)
range3 <- spatialAutoRange(rasterLayer = awt2,
sampleNumber = 5000,
doParallel = FALSE)
range3 <- spatialAutoRange(rasterLayer = awt,
speciesData = pa_data,
doParallel = FALSE)
rm(cov1)
tmp <- Sys.time()
cov1 <- covr::package_coverage(function_exclusions = c("foldExplorer", "rangeExplorer"))
Sys.time() - tmp
rm(tmp)
# print the coverage
cov1
# visualise the code coverage
report(cov1)
rm(cov1)
tmp <- Sys.time()
cov1 <- covr::package_coverage(function_exclusions = c("foldExplorer", "rangeExplorer"))
Sys.time() - tmp
rm(tmp)
# print the coverage
cov1
# visualise the code coverage
report(cov1)
rm(cov1)
# covr::codecov(token= "668a6472-722f-434d-9e77-0187bcb61a88")
covr::codecov(token= "668a6472-722f-434d-9e77-0187bcb61a88", function_exclusions = c("rangeExplorer", "foldExplorer"))
# loading the package
library(blockCV)
# loading raster library
library(raster)
library(sf)
# import raster data
awt <- raster::brick(system.file("extdata", "awt.grd", package = "blockCV"))
# import presence-absence species data
PA <- read.csv(system.file("extdata", "PA.csv", package = "blockCV"))
# make a SpatialPointsDataFrame object from data.frame
pa_data <- st_as_sf(PA, coords = c("x", "y"), crs = crs(awt))
# see the first few rows
pa_data
# plot species data on the map
plot(awt[[1]]) # plot raster data
plot(pa_data[which(pa_data$Species==1), ], pch = 16, col="red", add=TRUE) # add presence points
plot(pa_data[which(pa_data$Species==0), ], pch = 16, col="blue", add=TRUE) # add absence points
legend(x=500000, y=8250000, legend=c("Presence","Absence"), col=c(2, 4), pch=c(16,16), bty="n")
# import presence-background species data
PB <- read.csv(system.file("extdata", "PB.csv", package = "blockCV"))
# make a SpatialPointsDataFrame object from data.frame
pb_data <- st_as_sf(PB, coords = c("x", "y"), crs = crs(awt))
# number of presence and background records
table(pb_data$Species)
# spatial blocking by specified range with random assignment
sb <- spatialBlock(speciesData = pa_data,
species = "Species",
rasterLayer = awt,
theRange = 70000, # size of the blocks
k = 5,
selection = "random",
iteration = 100, # find evenly dispersed folds
biomod2Format = TRUE,
xOffset = 0, # shift the blocks horizontally
yOffset = 0)
# loading the libraries
library(randomForest)
library(precrec)
# library(ggplot2)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data, df=TRUE)
# adding species column to the dataframe
mydata$Species <- as.factor(pa_data$Species)
# remove extra column (ID)
mydata <- mydata[,-1]
# extract the folds in BufferedBlock object created in the previous section
folds <- sb$folds
# create a data.frame to store the prediction of each fold (record)
testTable <- pa_data
testTable$pred <- NA
for(k in seq_len(length(folds))){
trainSet <- unlist(folds[[k]][1]) # extract the training set indices
testSet <- unlist(folds[[k]][2]) # extract the testing set indices
rf <- randomForest(Species~., mydata[trainSet, ], ntree = 250) # model fitting on training set
testTable[testSet,"pred"] <- predict(rf, mydata[testSet, ], type = "prob")[,2] # predict the test set
}
# calculate Area Under the ROC and PR curves and plot the result
precrec_obj <- evalmod(scores = testTable$pred, labels = testTable$Species)
autoplot(precrec_obj)
library(ggplot2)
# loading the libraries
library(randomForest)
library(precrec)
# library(ggplot2)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data, df=TRUE)
# adding species column to the dataframe
mydata$Species <- as.factor(pa_data$Species)
# remove extra column (ID)
mydata <- mydata[,-1]
# extract the folds in BufferedBlock object created in the previous section
folds <- sb$folds
# create a data.frame to store the prediction of each fold (record)
testTable <- pa_data
testTable$pred <- NA
for(k in seq_len(length(folds))){
trainSet <- unlist(folds[[k]][1]) # extract the training set indices
testSet <- unlist(folds[[k]][2]) # extract the testing set indices
rf <- randomForest(Species~., mydata[trainSet, ], ntree = 250) # model fitting on training set
testTable[testSet,"pred"] <- predict(rf, mydata[testSet, ], type = "prob")[,2] # predict the test set
}
# calculate Area Under the ROC and PR curves and plot the result
precrec_obj <- evalmod(scores = testTable$pred, labels = testTable$Species)
autoplot(precrec_obj)
# loading the libraries
library(randomForest)
library(precrec)
# library(ggplot2)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data, df=TRUE)
# adding species column to the dataframe
mydata$Species <- as.factor(pa_data$Species)
# remove extra column (ID)
mydata <- mydata[,-1]
# extract the folds in BufferedBlock object created in the previous section
folds <- sb$folds
# create a data.frame to store the prediction of each fold (record)
testTable <- pa_data
testTable$pred <- NA
for(k in seq_len(length(folds))){
trainSet <- unlist(folds[[k]][1]) # extract the training set indices
testSet <- unlist(folds[[k]][2]) # extract the testing set indices
rf <- randomForest(Species~., mydata[trainSet, ], ntree = 250) # model fitting on training set
testTable[testSet,"pred"] <- predict(rf, mydata[testSet, ], type = "prob")[,2] # predict the test set
}
# calculate Area Under the ROC and PR curves and plot the result
precrec_obj <- evalmod(scores = testTable$pred, labels = testTable$Species)
autoplot(precrec_obj)
precrec_obj
precrec_obj$rocs
precrec_obj$rocs[1]
attr(precrec_obj$rocs, "auc")
attr(precrec_obj$rocs, "auc")
attr(precrec_obj$rocs, "auc")
attr(precrec_obj$rocs, "auc")[1]
auc(precrec_obj$rocs)
precrec_obj$rocs["auc"]
as.data.frame(precrec_obj$roc)
as.data.frame(precrec_obj$rocs)
precrec_obj$rocs["AUC"]
which(k != folds)
k
folds <- sb$foldID
which(k != folds)
# spatial blocking by rows and columns with checkerboard assignment
sb2 <- spatialBlock(speciesData = pb_data,
species = "Species",
rasterLayer = awt,
rows = 5,
cols = 6,
selection = "checkerboard",
biomod2Format = TRUE)
# spatial blocking by rows and columns with checkerboard assignment
sb2 <- spatialBlock(speciesData = pb_data,
species = "Species",
rasterLayer = awt,
rows = 5,
cols = 6,
selection = "systematic",
biomod2Format = TRUE)
# spatial blocking by rows and columns with checkerboard assignment
sb2 <- spatialBlock(speciesData = pb_data,
species = "Species",
rasterLayer = awt,
rows = 5,
cols = 6,
k = 5,
selection = "systematic",
biomod2Format = TRUE)
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$folds
folds
# buffering with presence-absence data
bf1 <- buffering(speciesData = pa_data,
theRange = 70000,
species = "Species", # to count the number of presences and absences/backgrounds
spDataType = "PA", # presence-absence  data type
progress = TRUE)
# loading the libraries
library(maxnet)
library(plotROC)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data)
mydata <- as.data.frame(mydata)
# create a vector of 1 (for presence) and 0 (for background samples)
pb <- pb_data$Species
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$folds
# create an empty vector to store the AUC of each fold
AUCs <- vector(mode = "numeric")
for(k in seq_len(length(folds))){
trainSet <- which(k != folds) # extract the training set indices
testSet <- which(k == folds) # extract the testing set indices
# fitting a maxent model using linear, quadratic and hinge features
mx <- maxnet(p = pb[trainSet],
data = mydata[trainSet, ],
maxnet.formula(p = pb[trainSet],
data = mydata[trainSet, ],
classes = "default"))
testTable <- pb_data[testSet, ] # a table for testing predictions and reference data
testTable$pred <- predict(mx, mydata[testSet, ], type="cloglog") # predict the test set
# calculate AUC using calc_auc function in plotROC package
auc <- calc_auc(ggplot(testTable, aes(m=pred, d=Species)) + geom_roc(n.cuts = 0))[3]
AUCs[k] <- as.numeric(auc)
}
# loading the libraries
library(maxnet)
library(plotROC)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data)
mydata <- as.data.frame(mydata)
# create a vector of 1 (for presence) and 0 (for background samples)
pb <- pb_data$Species
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$folds
# create an empty vector to store the AUC of each fold
AUCs <- vector(mode = "numeric")
for(k in seq_len(unique(folds))){
trainSet <- which(k != folds) # extract the training set indices
testSet <- which(k == folds) # extract the testing set indices
# fitting a maxent model using linear, quadratic and hinge features
mx <- maxnet(p = pb[trainSet],
data = mydata[trainSet, ],
maxnet.formula(p = pb[trainSet],
data = mydata[trainSet, ],
classes = "default"))
testTable <- pb_data[testSet, ] # a table for testing predictions and reference data
testTable$pred <- predict(mx, mydata[testSet, ], type="cloglog") # predict the test set
# calculate AUC using calc_auc function in plotROC package
auc <- calc_auc(ggplot(testTable, aes(m=pred, d=Species)) + geom_roc(n.cuts = 0))[3]
AUCs[k] <- as.numeric(auc)
}
seq_len(unique(folds))
seq_len(unique(folds))
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$folds
seq_len(unique(folds))
folds
seq_len(unique(folds))
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$foldID
folds
seq_len(unique(folds))
unique(folds)
seq_len(max(folds))
seq_len(5)
# loading the libraries
library(maxnet)
library(plotROC)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data)
mydata <- as.data.frame(mydata)
# create a vector of 1 (for presence) and 0 (for background samples)
pb <- pb_data$Species
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$foldID
# create an empty vector to store the AUC of each fold
AUCs <- vector(mode = "numeric")
for(k in seq_len(5)){
trainSet <- which(k != folds) # extract the training set indices
testSet <- which(k == folds) # extract the testing set indices
# fitting a maxent model using linear, quadratic and hinge features
mx <- maxnet(p = pb[trainSet],
data = mydata[trainSet, ],
maxnet.formula(p = pb[trainSet],
data = mydata[trainSet, ],
classes = "default"))
testTable <- pb_data[testSet, ] # a table for testing predictions and reference data
testTable$pred <- predict(mx, mydata[testSet, ], type="cloglog") # predict the test set
# calculate AUC using calc_auc function in plotROC package
auc <- calc_auc(ggplot(testTable, aes(m=pred, d=Species)) + geom_roc(n.cuts = 0))[3]
AUCs[k] <- as.numeric(auc)
}
folds
seq_len(5)
k
trainSet <- which(k != folds)
trainSet
testSet <- which(k == folds)
testSet
which(folds != k)
which(folds == k)
trainSet <- which(folds != k) # extract the training set indices
testSet <- which(folds == k) # extract the testing set indices
# fitting a maxent model using linear, quadratic and hinge features
mx <- maxnet(p = pb[trainSet],
data = mydata[trainSet, ],
maxnet.formula(p = pb[trainSet],
data = mydata[trainSet, ],
classes = "default"))
# loading the libraries
library(maxnet)
library(plotROC)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pb_data)
mydata <- as.data.frame(mydata)
# create a vector of 1 (for presence) and 0 (for background samples)
pb <- pb_data$Species
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$foldID
# create an empty vector to store the AUC of each fold
AUCs <- vector(mode = "numeric")
for(k in seq_len(5)){
trainSet <- which(folds != k) # extract the training set indices
testSet <- which(folds == k) # extract the testing set indices
# fitting a maxent model using linear, quadratic and hinge features
mx <- maxnet(p = pb[trainSet],
data = mydata[trainSet, ],
maxnet.formula(p = pb[trainSet],
data = mydata[trainSet, ],
classes = "default"))
testTable <- pb_data[testSet, ] # a table for testing predictions and reference data
testTable$pred <- predict(mx, mydata[testSet, ], type="cloglog") # predict the test set
# calculate AUC using calc_auc function in plotROC package
auc <- calc_auc(ggplot(testTable, aes(m=pred, d=Species)) + geom_roc(n.cuts = 0))[3]
AUCs[k] <- as.numeric(auc)
}
# print the mean and standard deviation of AUCs
print(mean(AUCs))
precrec_obj
auc(precrec_obj)
auc(precrec_obj)[1,3]
auc(precrec_obj)[1,]
auc(precrec_obj)[1,4]
# loading the libraries
library(maxnet)
library(ROCR)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pb_data)
mydata <- as.data.frame(mydata)
# create a vector of 1 (for presence) and 0 (for background samples)
pb <- pb_data$Species
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$foldID
# create an empty vector to store the AUC of each fold
AUCs <- vector(mode = "numeric")
for(k in seq_len(5)){
trainSet <- which(folds != k) # extract the training set indices
testSet <- which(folds == k) # extract the testing set indices
# fitting a maxent model using linear, quadratic and hinge features
mx <- maxnet(p = pb[trainSet],
data = mydata[trainSet, ],
maxnet.formula(p = pb[trainSet],
data = mydata[trainSet, ],
classes = "default"))
testTable <- pb_data[testSet, ] # a table for testing predictions and reference data
testTable$pred <- predict(mx, mydata[testSet, ], type = "cloglog") # predict the test set
# calculate AUC using calc_auc function in plotROC package
precrec_obj <- evalmod(scores = testTable$pred, labels = testTable$Species)
AUCs[k] <- auc(precrec_obj)[1,4] # extract AUC-ROC
}
# print the mean and standard deviation of AUCs
print(mean(AUCs))
# loading the libraries
library(maxnet)
library(precrec)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pb_data)
mydata <- as.data.frame(mydata)
# create a vector of 1 (for presence) and 0 (for background samples)
pb <- pb_data$Species
# extract the folds in spatialBlock object created in the previous section (with presence-background data)
folds <- sb2$foldID
# create an empty vector to store the AUC of each fold
AUCs <- vector(mode = "numeric")
for(k in seq_len(5)){
trainSet <- which(folds != k) # extract the training set indices
testSet <- which(folds == k) # extract the testing set indices
# fitting a maxent model using linear, quadratic and hinge features
mx <- maxnet(p = pb[trainSet],
data = mydata[trainSet, ],
maxnet.formula(p = pb[trainSet],
data = mydata[trainSet, ],
classes = "default"))
testTable <- pb_data[testSet, ] # a table for testing predictions and reference data
testTable$pred <- predict(mx, mydata[testSet, ], type = "cloglog") # predict the test set
# calculate AUC using calc_auc function in plotROC package
precrec_obj <- evalmod(scores = testTable$pred, labels = testTable$Species)
AUCs[k] <- auc(precrec_obj)[1,4] # extract AUC-ROC
}
# print the mean and standard deviation of AUCs
print(mean(AUCs))
# loading the libraries
library(randomForest)
library(precrec)
# library(ggplot2)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data, df=TRUE)
# adding species column to the dataframe
mydata$Species <- as.factor(pa_data$Species)
# remove extra column (ID)
mydata <- mydata[,-1]
# extract the foldIDs in SpatialBlock object created in the previous section
folds <- bf1$folds
# create a data.frame to store the prediction of each fold (record)
testTable <- pa_data
testTable$pred <- NA
for(k in seq_len(length(folds))){
trainSet <- unlist(folds[[k]][1]) # extract the training set indices
testSet <- unlist(folds[[k]][2]) # extract the testing set indices
rf <- randomForest(Species~., mydata[trainSet, ], ntree = 250) # model fitting on training set
testTable$pred[testSet] <- predict(rf, mydata[testSet, ], type = "prob")[,2] # predict the test set
}
# calculate Area Under the ROC and PR curves and plot the result
precrec_obj <- evalmod(scores = testTable$pred, labels = testTable$Species)
autoplot(precrec_obj)
precrec_obj
# loading the libraries
library(randomForest)
library(precrec)
# extract the raster values for the species points as a dataframe
mydata <- raster::extract(awt, pa_data, df=TRUE)
# adding species column to the dataframe
mydata$Species <- as.factor(pa_data$Species)
# remove extra column (ID)
mydata <- mydata[,-1]
# extract the foldIDs in SpatialBlock object created in the previous section
folds <- bf1$folds
# create a data.frame to store the prediction of each fold (record)
testTable <- pa_data
testTable$pred <- NA
for(k in seq_len(length(folds))){
trainSet <- unlist(folds[[k]][1]) # extract the training set indices
testSet <- unlist(folds[[k]][2]) # extract the testing set indices
rf <- randomForest(Species~., mydata[trainSet, ], ntree = 250) # model fitting on training set
testTable$pred[testSet] <- predict(rf, mydata[testSet, ], type = "prob")[,2] # predict the test set
}
# calculate Area Under the ROC and PR curves and plot the result
precrec_obj <- evalmod(scores = testTable$pred, labels = testTable$Species)
autoplot(precrec_obj)
precrec_obj
autoplot(precrec_obj)
library(blockCV)
library(blockCV)
library(blockCV)
usethis::use_appveyor()
